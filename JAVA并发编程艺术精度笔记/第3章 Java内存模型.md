# 第3章 Java内存模型

内存模型

内存模型中的顺序一致性，重排序以及顺序一致性内存模型

同步原语：synchronized，volatile，final

## 一、Java内存模型的基础

#### 1.1. 并发编程模型的两个关键问题（通信、同步）：

* 线程之间如何**通信**
* 线程之间如何**同步**

线程之间**通信**机制有两种：共享内存、消息传递

**同步**：**程序中用于控制不同线程间操作发生相对顺序的机制**。

两种并发模型：

* **共享内存**：（Java采用该并发模型）

  通信：线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<u>隐式</u>通信。

  同步：<u>显式</u>进行，程序员必须<u>显式指定</u>某个方法或某段代码需要在线程之间互斥执行。

* **消息传递**：

  通信：显式，线程之间没有公共状态，线程之间必须通过发送消息来<u>显式</u>通信。

  同步：隐式，由于消息发送必须先于接收，所以同步是隐式进行的。

<u>Java采用的是**共享内存**模型</u>

### 1.2. Java内存模型的抽象结构

![Java内存模型的抽象结构示意图](static/图3-1 Java内存模型的抽象结构示意图.jpg)

Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入合适对另一个线程可见。

抽象角度看：

线程之间的**共享变量存储在主内存**（Main Memory）；每个**线程都有一个私有的本地内存**（抽象概念，不真实存在）；**本地内存中存储了该线程以读/写共享变量的副本**。

A-->B的通信步骤：

1. 线程A把本地内存A中**更新过的共享变量刷新到主内存**中。
2. 线程B**到主内存中读取**线程A之前已更新过的共享变量。

**实质**：线程A在向线程B发消息，而且**必须经过主内存**。

<u>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</u>



### 1.3. 从源代码到指令序列的重排序

为了提高执行程序的性能，编译器和处理器常常会对指令做重排序(3种)。

```flow
op1=>operation: 源代码
op2=>operation: 1：编译器
优化重排序
op3=>operation: 2：指令级
并行重排序
op4=>operation: 3：内存系统
重排序
op5=>operation: 4：最终执行的指令序列

op1(right)->op2(right)->op3(right)->op4(right)->op5
```

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，重新安排语句执行顺序。
2. 指令级并行的重排序。处理器采用指令级并行技术将多条指令重叠执行。（如无数据依赖可改变执行顺序）
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去是在乱序执行。

每个处理器写缓冲区仅对自己可见，这会导致处理器执行内存操作的顺序会与内存实际的操作执行顺序不一致。因此现代的处理器都会允许对写-读操作进行重排序。

JMM通过禁止某些编译器重排序（插入内存屏障）和处理器重排序，为程序员提供一致的内存可见性保证。



### 1.4. happens-before

Java的JSR-133内存模型使用happens-before的概念来阐述操作之间的内存可见性。

在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。（两个操作可以是同一线程内，也可以是不同线程之间）

+ **happens-before**仅仅要求**前一个操作执行的结果对后一个操作可见**，且前一个操作按**顺序**排在第二个操作之前。**并不意味**着前一个操作必须在后一个操作前执行！

与**程序员密切相关的happens-before规则**如下：

+ **程序顺序规则**：一个线程中的**每个操作**，**happens-before于**该线程中的任意**后续操作**。（同一线程内顺序排序）
+ **监视器锁规则**：对一个锁的**解锁**，**happens-before于**随后对其**加锁**。（解锁-->加锁）
+ **volatile变量规则**：对一个**volatile域的写**，**happens-before于**任意后续对这个**volatile域的读**。（写-->读）
+ **传递性**：如果A happens-before B，且B happens-before C，那么A happens-before C

happens-before与JMM的关系：

```flow
op1=>start: 程序员
op2=>operation: happens-before 规则
(JMM呈现给程序员的视图部分）
op3=>operation: 禁止某种类型的
编译器/处理器重排序
( JMM的实现 )
op4=>operation: 处理器/编译器重排序规则
(JMM定义的规则)

op1(right)->op2(right)->op3(right)->op4
```

## 二、重排序

重排序是指编译器和处理器优化程序性能而对指令序列进行重新排序的一种手段。

### 2.1. 数据依赖性

两个操作访问同一个变量，其中一个是写操作，则存在数据依赖性。

分为：

+ 写后读
+ 写后写
+ 读后写

上述三种情况，只要重排序两个操作，执行结果就会被改变。

编译器和处理器会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序（仅针对单个处理器和单个线程中的操作，不同处理器之间和不同线程之间的数据依赖性不被考虑）

###2.2. as-if-serial语义

**as-if-serial：不管怎么重排序，（单线程）程序的执行结果不能被改变。**	//(个人理解为数据库事务的可串行化)

编译器、runtime、处理器都**必须遵守**as-if-serial语义，因此它们**不会对存在数据依赖关系的操作**做重排序。

as-if-serial语义**保护了单线程**程序。使单线程程序员无需担心重排序会干扰到程序和内存可见性问题。

### 2.3. 程序顺序规则

软件和硬件技术准求的目标：在**不改变程序执行结果**的前提下，尽可能**提高并行度**。

编译器和处理器遵从这一目标，JMM也同样遵从这一目标(happens-before)